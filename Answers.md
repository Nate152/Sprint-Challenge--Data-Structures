1. Stacks exhibit a LIFO, last in first out, priority for additions and removals. The last property of the stack(array) will be the first one removed with built in methods. Queues exhibit a FIFO, first in first out, priority. This means that the first property added to the queue will also be the first removed.

2. The retrieval time complexity for a singly linked list is O(n). You must search through each item in the list in order to access something so the retrieval time is directly correlated to the number of items in the list. The time complexity for a hash table is O(1) for retrieval. The data is essentially presorted using this data structure and we only have to search one "bucket" in the table for the value/data. The time complexity for a binary search tree is O(log(n)). For data retrieval the search tree is able to consitently half the amount of nodes that it has to look through as it searches for the data. Initially the tree is able to eliminate a significant number of nodes in the tree due to its ordered structure. As we search further down the tree we continue to cut the number of nodes in half but not at the same rate as time(0). This is one of the fastest ways to retrieve data from a data structure.

3. Hash tables allow us to use a hash funtion to sort data into different buckets within the table. These buckets can be used to quickly access data in the table because the computer knows exactly where the data is stored. We do not have to search through all of the buckets in order to find a particular value. If we used arrays instead of hash tables, we would have to iterate through each value within the array, which takes time that is ulimately wasted. Hash tables often use arrays as the buckets so we still have the access to all the methods on the array prototype, but with a much faster way to accesss the data within each array.

* I did attempt the exercise to use linked lists instead of arrays for buckets however I was doing so in a different file and my computer did a windows update about 3 hours into the challenge. Needless to say I lost it, but I wasnt able to make much headway on it. These concepts are still very confusing to me when it comes to actual implementation. Conceptually I feel that I have a pretty good grasp, its writing the actual code that I struggle with at this time.*